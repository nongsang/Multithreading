#include <iostream>
#include <thread>		// 스레드를 사용하려면 추가해야 한다.

using namespace std;	// 성능을 제대로 확인하기 위해서 Release모드로 실행한다.
						// 일부러 오류는 내려고 해도 나오지 않는 경우는 Debug모드로 실행해본다.

int sum;	// 공유메모리 모델을 사용하기 위해서 전역 변수를 사용한다.

void Thread_Func()
{
	for (auto i = 0; i < 25000000; ++i)	// 2500만번
		sum += 2;						// sum에 2씩 저장한다.
}

int main()		// main()을 실행하기 위해서도 스레드를 1개 사용한다.
{
	thread t1 = thread{ Thread_Func };	// C++에서 스레드 생성방법
	thread t2 = thread{ Thread_Func };	// C#에서는 Thread.Start()를 사용해야하지만 C++은 생성하자마자 작업한다.

	t1.join();		// C++에서는 join을 해서 스레드들이 작업을 끝날 때 까지 기다리게 해야 오류가 발생하지 않는다.
	t2.join();		// t1, t2는 main 스레드에 종속적이다.
					// t1, t2가 실행되는 도중에 main 스레드가 끝나면 모든 데이터를 삭제하므로 t1, t2까지 삭제를 하게 된다.
					// t1, t2가 작업도중에 삭제를 하면 오류를 발생한다.
					// t1, t2가 끝나기를 기다리고 main 스레드를 삭제해야 오류를 방지할 수 있다.
					// 따라서 C++에서는 반드시 join을 했는지 확인한다.
	cout << "sum : " << sum << endl;	// 2씩 2500만번 저장하는 기능을 2개의 스레드가 작업하므로 총 1억이 나와야 한다.
										// 하지만 1억보다는 무조건 작은 값이 나온다.
										// 1. sum값을 가져온다. 2. 2를 더한다. 3. 갱신한다.의 작업순서를 가진다.
										// t1이 값을 갱신한 뒤에 t2가 sum값을 가져온다면 문제는 없다.
										// 하지만 t1이 sum값을 가져와서 2를 더하는 동안 t2가 sum값을 가져오는 경우가 있다.
										// t1과 t2가 같은 값을 가지고 있는 상태이기 때문에 t1이 새로운 값을 갱신하더라도 t2가 같은 값을 갱신하게 된다.
										// 따라서 최종값이 무조건 1억 미만일 수 밖에 없다.
										// 이를 데이터레이스라고 한다.
}