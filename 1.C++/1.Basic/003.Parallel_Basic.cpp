#include <iostream>
#include <thread>
#include <string>

using namespace std;

int Fib(int n)	// 피보나치 수열, 입력값이 커지면 기하급수적으로 성능이 하락한다.
{
	if( 0 == n ) return 0;
	else if( 1 == n ) return 1;
	else return Fib(n - 1) + Fib(n - 2);
}

int main()
{
	cout << "피보나치 수열 구하기 (종료 'x')" << endl;

	string input;	// 공유 메모리, 일부러 while문 전에 선언했다.

	while( true )
	{
		cout << "숫자를 입력하세요. : ";

		cin >> input;

		if( input == "x" )					// x가 입력되면 프로그램 종료
		{									// 서브 스레드들이 모두 강제로 종료
			cout << "프로그램 종료" << endl;
			break;
		}

		//thread t = thread{ [&] { cout << Fib(atoi(input.c_str())) << endl; } };	// 서브 스레드를 생성하여 연산을 맡긴다.
																				// 메인 스레드는 서브 스레드를 생성하고 다시 입력을 기다린다.
																				// 서브 스레드가 연산을 하고 있어도 입력을 받을 때 마다 서브 스레드를 생성하여 연산을 맡긴다.
																				// 여전히 동기방식이지만 스레드를 생성해서 전담하는 방식으로 동기방식의 문제를 해결했다.
																				// 메인 스레드, 서브 스레드 각자 나름대로 동시에 일을 하는 것이기 때문에 병렬(Parallel)처리를 한 것이다.
		//t.detach();	// 스레드 변수와 실행중인 스레드의 연결을 끊는다.
						// 연결을 끊는다고 실행중이던 작업이 중지되는 것이 아니다.
						// 익명 스레드처럼 따로 조작을 하지 못하게만 되는 것이다.
						// 익명 스레드로 변하게 되므로 메인 스레드에 연산 결과값을 전달할 필요가 없다는 의미가 된다.
						// 따라서 조인을 하지 않아도 된다.

		new thread{ [&] { cout << Fib(atoi(input.c_str())) << endl; } };	// 조인이 필요없다면 익명 스레드를 생성하는 것도 좋다.
	}

	//t.join();	// 여기서는 조인을 하지 않았다.
				// 이유는
				// 1. t는 while문 안에서 생성했기 때문에 while문 밖에서 t에 접근을 할 수 없다. (스택프레임문제)
				// 2. t의 스레드 연산 결과는 메인 스레드가 필요로 하지 않다. (설계)
				// 3. 메인 스레드가 종료하면 서브 스레드도 종료하게 하고 싶다. (스레드 변수 연결 X)
}